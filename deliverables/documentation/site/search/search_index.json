{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MyShelfie`s documentation!","text":""},{"location":"#welcome-to-myshelfies-documentation","title":"Welcome to MyShelfie`s documentation!","text":"<p>Go to the JavaDoc!</p> <p>MyShelfie is a game developed by Cranio Creations, as a physical board game.</p> <p>This project is a digital adaptation of the game, developed by the GC07 team, as part of the Software Engineering course at Politecnico di Milano.</p> <p>The team members are:</p> <ul> <li>Gabriele Puglisi</li> <li>Matteo Santelmo</li> <li>Giuseppe Steduto</li> <li>Mattia Vicenzotto</li> </ul>"},{"location":"#navigating-the-documentation","title":"Navigating the documentation","text":"<p>You can use the navigation bar on the left to navigate the documentation.</p>"},{"location":"#running-the-client","title":"Running the client","text":"<p>If you want to connect to an already running server, head over to the client documentation.</p>"},{"location":"#running-the-server","title":"Running the server","text":"<p>If you want to run your own server, head over to the server documentation.</p>"},{"location":"#dive-deep-in-the-design","title":"Dive deep in the design","text":"<p>If you want to have a look at the advanced features of this game, check these pages out:</p> <ul> <li>Handling client disconnections</li> <li>Making the server crash-proof</li> <li>Handling multiple games at once</li> </ul> <p>If you want to have a look at the UML diagrams, check out these links:</p> <ul> <li>UML Class diagrams:<ul> <li>Client</li> <li>Network, Controller and Model</li> <li>Network detail</li> </ul> </li> <li>UML Sequence diagrams and network communication protocol:<ul> <li>Client-server network communication protocol</li> </ul> </li> </ul> <p>Following the best practices of software engineering, we made sure that our code is well documented and tested. The Javadoc is available here. The test coverage report is available here.</p> <p>If you want to peek into our development process, we have described it and the tools  we have used in the development process page.</p>"},{"location":"#manual-installation","title":"Manual installation","text":"<p>If you want to install the game manually, head over to the manual installation page.</p>"},{"location":"advanced-features/disconnection/","title":"Client disconnection","text":""},{"location":"advanced-features/disconnection/#client-disconnection","title":"Client disconnection","text":"<p>One of the advanced features this game implements is the handling of client disconnections. It is done in a way that is transparent to the client, and that allows the client to rejoin a game even after it disconnected, without pausing the game for the other players.</p>"},{"location":"advanced-features/disconnection/#how-it-works","title":"How it works","text":"<p>When a client connects to the server (either via RMI or via Socket), it is registered with a unique nickname. After the client receives confirmation of the registration, it starts a thread that periodically (every <code>HEARTBEAT_PERIOD</code> seconds) sends a \"heartbeat\" message to the server. The default value for <code>HEARTBEAT_PERIOD</code> is 5 seconds.</p> <p>The server, on the other hand, after registering a client, starts for each client a thread that checks if the last heartbeat of the client was received within a certain time interval (we set it as double the heartbeat interval).</p>"},{"location":"advanced-features/disconnection/#disconnection","title":"Disconnection","text":"<p>If the last heartbeat is too old (more than <code>HEARTBEAT_TIMEOUT</code> has passed), the server considers the client disconnected, and performs different actions depending on the status of the game in which the client was playing:</p> <ul> <li>If the client had not yet joined a game (i.e. before joining a lobby or in the \"waiting stage\"   in the lobby), the server simply removes the client from the list of registered clients and from   the lobby, if it was waiting for a game inside one.</li> <li>If the client was in a game, the server will set the player status to \"disconnected\", and will notify the other   clients in the game that the client disconnected with the first message it sends to the game. If there are stillThe game   at least two players online in the game, the game does not stop and the player is not removed (so that they   can reconnect later). Simply, its turn is skipped, and the other players can continue playing.</li> </ul>"},{"location":"advanced-features/disconnection/#reconnection","title":"Reconnection","text":"<p>If the client was playing in a game and got disconnected, to rejoin the game it only has to reconnect to the server using the same nickname with which it registered the first time. The server will automatically set the player status back to \"online\", and will notify the other clients in the game that the client reconnected with the first message it sends to the game. The game will continue.</p>"},{"location":"advanced-features/multiple-games/","title":"Multiple games: one server to rule them all","text":""},{"location":"advanced-features/multiple-games/#multiple-games-one-server-to-rule-them-all","title":"Multiple games: one server to rule them all","text":"<p>Our game's server architecture, built to support multiple games concurrently, ensures seamless operation and high performance through the careful use of design patterns and data structures.</p>"},{"location":"advanced-features/multiple-games/#sequence-diagram","title":"Sequence diagram","text":""},{"location":"advanced-features/multiple-games/#the-heart-of-communication","title":"The Heart of Communication","text":"<p>At the heart of our communication pipeline is the <code>LobbyController</code> class, a critical component that acts as a bridge between clients and their respective games. It receives messages from clients through either Remote Method Invocation (RMI) or Socket, based on the client's preference.</p> <p><code>LobbyController</code> employs a mapping system to manage active games. Each game is uniquely identified by a string representing its name. This name is used as a key in a map that associates each game with its corresponding <code>GameController</code> instance.</p>"},{"location":"advanced-features/multiple-games/#handling-commands-and-actions","title":"Handling Commands and Actions","text":"<p>Every action performed by a user is translated into a command which is sent to the server, which forwards it to the <code>LobbyController</code>, which in turn dispatches it to the associated <code>GameController</code>. To ensure responsiveness and concurrency control, the <code>GameController</code> adds the command to a queue, allowing it to return control to the <code>LobbyController</code> immediately without having to wait for the execution of the command. The command queue is managed by a single-threaded executor to guarantee that commands are processed sequentially and in the order they were received, thereby avoiding concurrency issues.</p>"},{"location":"advanced-features/persistence/","title":"Persistence: making the server crash-proof","text":""},{"location":"advanced-features/persistence/#persistence-making-the-server-crash-proof","title":"Persistence: making the server crash-proof","text":"<p>Our  game server has a built-in persistence feature that allows it to withstand crashes and restore a previously saved state. This functionality ensures a seamless gaming experience for the players, minimizing the impact of unexpected server disruptions.</p>"},{"location":"advanced-features/persistence/#how-it-works","title":"How it works","text":"<p>The server maintains a comprehensive map of <code>GameController</code> instances which holds the state of each game and the players connected to it. Whenever a user performs a command in any game, the server's status is saved to a local <code>serverBackup.ser</code> file.</p> <p>The method responsible for writing this file is declared as <code>synchronized</code>. This keyword ensures that multiple <code>GameController</code> instances cannot access the file concurrently, avoiding potential inconsistencies or corruption in the saved state.</p>"},{"location":"advanced-features/persistence/#restoring-the-server-state","title":"Restoring the server state","text":"<p>When restarting the server, you can use the <code>--backup</code> flag to attempt a restoration of the previous state from the <code>serverBackup.ser</code> file. This way, the game can pick up from where it left off.</p> <p>Warning</p> <p>Every time the server starts, the <code>serverBackup.ser</code> file is overwritten with the new state of the server. If you run it without the <code>--backup</code> flag, the previous saved state will be lost.</p> <p>This feature contributes to the robustness and reliability the game.</p>"},{"location":"client/","title":"Client documentation","text":""},{"location":"client/#client-documentation","title":"Client documentation","text":"<p>This documentation page aims to provide you with detailed instructions on how to set up and run the client-side software of the game.</p> <p>Note</p> <p>Before we begin, ensure that you have the server component of the game up and running. Head over to the server documentation for instructions on how to do that.</p>"},{"location":"client/#prerequisites","title":"Prerequisites","text":"<p>The MyShelfie client is built on Java, therefore it requires a Java Runtime Environment (JRE) to function. Please make sure that you have JRE installed on your system and it is of version 19 or later.</p> <p>To check your Java version, use the following command in your terminal or command prompt:</p> <pre><code>java -version\n</code></pre>"},{"location":"client/#getting-started","title":"Getting Started","text":"<p>Kickstarting the client is a straightforward process. First, navigate to the <code>deliverables/jar</code> directory. The file <code>client-myshelfie.jar</code> is what you're looking for, this is the compiled JAR file for the client.</p> <p>The format of the command to run the client is the following:</p> <pre><code>java -jar ./client-myshelfie.jar [--cli|--gui] [--server-address=&lt;server-address&gt;] [--socket|--rmi]\n</code></pre>"},{"location":"client/#command-line-arguments","title":"Command-line arguments","text":"<p>To customize your gaming experience, there are several optional command-line parameters you can utilize:</p> <ul> <li><code>--cli</code> or <code>--gui</code>: These flags allow you to choose between the textual and graphical interfaces of the game. If you don't specify anything, the game is launched with the graphical interface by default.</li> <li><code>--server-address=&lt;server-address&gt;</code>: This parameter allows you to specify the server address if it's different from the default one (localhost).</li> <li><code>--socket</code> or <code>--rmi</code>: These flags allow you to choose between the socket and RMI connection types. If you don't specify anything, the game is launched with the socket connection by default.</li> </ul> <p>Tip</p> <p>The <code>--server-address</code> parameter accepts both IP addresses and hostnames. This provides flexibility in case you have a valid DNS record for your server in the DNS server used by your client.</p>"},{"location":"client/#example-usage","title":"Example usage","text":"<p>Here's an example of using these parameters:</p> <pre><code>java -jar ./client-myshelfie.jar --cli --socket --server-address=192.168.1.51\n</code></pre>"},{"location":"demo/","title":"Gameplay Gallery","text":""},{"location":"demo/#gameplay-gallery","title":"Gameplay Gallery","text":"<p>Still not convinced about how great our game is? Here are some screenshots and videos of the game in action:</p>"},{"location":"demo/#cli","title":"CLI","text":"<p>Below are some screenshots of the CLI (textual interface) version of the client.</p> <p> </p> The first phase of the game is the login: insert your nickname! <p> </p> After login, you can choose to either create a new game, or join an existing one <p> </p> Let's create the game \"mushroom\" with 3 players! <p> </p> Another player will select the \"mushroom\" game, and the fun can start! <p> </p> It's your turn! Select the tiles from the board... <p> </p> ...and place them inside the bookshelf!"},{"location":"demo/#gui","title":"GUI","text":"<p>For the graphical interface, let's do something different: a video!</p> <p> </p> Again, let's start by typing in the nickname <p></p> Now you can select the game that you want to join <p></p> Then, enjoy the game in a completely new fashion!"},{"location":"development-process/","title":"Tools and development process","text":""},{"location":"development-process/#tools-and-development-process","title":"Tools and development process","text":""},{"location":"development-process/#maven","title":"Maven","text":"<p>We used Maven as our build automation tool. It allowed us to easily manage the dependencies of the project, and to automatically build the project and run the tests. Using the <code>pom.xml</code>, we were able to include inside the jar file all the dependencies needed to run the game, with a particular focus on making the client application cross-platform: we included the JavaFX dependencies for all the supported platforms (Windows, Linux and macOS), like this:</p> <pre><code>&lt;!-- JavaFX - win --&gt;\n...omitted for brevity...\n\n&lt;dependency&gt;\n&lt;groupId&gt;org.openjfx&lt;/groupId&gt;\n&lt;artifactId&gt;javafx-fxml&lt;/artifactId&gt;\n&lt;version&gt;\n19\n  &lt;/version&gt;\n&lt;classifier&gt;win&lt;/classifier&gt;\n&lt;/dependency&gt;\n\n&lt;!-- JavaFX - mac-aarch64OS --&gt;\n...omitted for brevity...\n\n&lt;dependency&gt;\n&lt;groupId&gt;org.openjfx&lt;/groupId&gt;\n&lt;artifactId&gt;javafx-fxml&lt;/artifactId&gt;\n&lt;version&gt;\n19\n  &lt;/version&gt;\n&lt;classifier&gt;mac-aarch64&lt;/classifier&gt;\n&lt;/dependency&gt;\n\n&lt;!-- JavaFX - linux --&gt;\n...omitted for brevity...\n\n&lt;dependency&gt;\n&lt;groupId&gt;org.openjfx&lt;/groupId&gt;\n&lt;artifactId&gt;javafx-fxml&lt;/artifactId&gt;\n&lt;version&gt;\n19\n  &lt;/version&gt;\n&lt;classifier&gt;linux&lt;/classifier&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"development-process/#git-and-github","title":"Git and GitHub","text":"<p>We used Git as our version control system, and GitHub as our remote repository. We used the GitHub issues to keep track of the tasks to be done, and to assign them to the team members, to comments </p>"},{"location":"development-process/#branching-model-and-code-review-process","title":"Branching model and code review process","text":"<p>We used a scaled trunk-based branching model, with a single <code>main</code> branch and a single remote. We used the <code>main</code> branch as our \"production\" branch, and we used feature branches to develop new features. Whenever a feature was ready, we opened a pull request to merge it into the <code>main</code> branch: using GitHub really made it easy for us to review the code of our teammates, and to discuss about it: </p> <p>Thanks to GitHub, it was easy to link the issues with the related pull requests, and to automatically close the issues when the pull request was merged into the <code>main</code> branch. </p>"},{"location":"development-process/#github-actions","title":"GitHub Actions","text":"<p>We set up GitHub Actions to automatically run the tests whenever a pull request was opened, or whenever a commit was pushed to the <code>main</code> branch. This allowed us to quickly spot any regression, and to fix it before merging the code into the <code>main</code> branch (at least until we ran out of free minutes, and we had to disable the  workflow).</p> <p></p>"},{"location":"development-process/#intellij-idea","title":"IntelliJ IDEA","text":"<p>We used IntelliJ IDEA as our IDE. It allowed us to easily manage the dependencies of the project, and to automatically build the project and run the tests. We particularly liked the integration with GitHub, and the ability to choose different run configurations, both for testing and for running the application, while being able to easily visualize the code coverage of the tests.</p>"},{"location":"legal/","title":"License","text":""},{"location":"legal/#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license. </p><pre><code>Copyright (c) 2012-2023 Gabriele Puglisi, Matteo Santelmo,\nGiuseppe Steduto, and Mattia Vicenzotto\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"manual-installation/","title":"Manual installation","text":""},{"location":"manual-installation/#manual-installation","title":"Manual installation","text":"<p>So you want to get your hands dirty install the game manually? No problem! This page will guide you through the process.</p> <p>Note</p> <p>Keep in mind that both the server and the client application are already pre-built and ready to run! You can find them in the <code>deliverables/jar</code> folder of the repository, and the instruction on how to run them are in the client and server documentation pages.</p>"},{"location":"manual-installation/#requirements","title":"Requirements","text":"<p>In order to run the game, you need to have the following software installed on your machine:</p> <ul> <li>Java SE JDK 19 or higher</li> <li>JavaFX 19 or higher (they don't come bundled with the JDK anymore)</li> <li>Maven 3.6.3 or higher</li> </ul>"},{"location":"manual-installation/#building-the-project","title":"Building the project","text":"<p>First of all, you need to clone the repository on your machine. You can do so by running the following command:</p> <pre><code>git clone GabP404/ing-sw-2023-Puglisi-Vicenzotto-Santelmo-Steduto\ncd ing-sw-2023-Puglisi-Vicenzotto-Santelmo-Steduto\n</code></pre> <p>Then, you need to build the project. You can do so by running the following command:</p> <pre><code>mvn clean package\n</code></pre> <p>A new folder called <code>target</code> will be created in the root of the project. Inside it, you will find the jar files, which already include all the dependencies needed to run the game.</p> <p>Easier than you thought, right?</p>"},{"location":"manual-installation/#running-the-game","title":"Running the game","text":"<p>Head over to the client and server documentation pages to learn how to run the game.</p>"},{"location":"server/","title":"Server documentation","text":""},{"location":"server/#server-documentation","title":"Server documentation","text":"<p>This documentation page aims to provide you with detailed instructions on how to set up and run the server-side software of the game.</p>"},{"location":"server/#running-the-server","title":"Running the Server","text":"<p>Initiating the server requires a few simple steps. First, navigate to the <code>deliverables/jar</code> directory. In this directory, you'll find the <code>server-myshelfie.jar</code> file which contains the server program.</p> <p>The format of the command to run the server is the following:</p> <pre><code>java -jar ./server-myshelfie.jar [--logging=&lt;debug|info|error&gt;] [--server-address=&lt;server-address&gt;]\n</code></pre>"},{"location":"server/#command-line-arguments","title":"Command-line arguments","text":"<p>For custom server configurations, we provide several optional command-line parameters:</p> <ul> <li><code>--server-address=&lt;server-address&gt;</code>: Specifies the IP address of the interface on which the RMI registry will be bound, as seen by the client. If not specified, the server will bind to the loopback interface (127.0.0.1).</li> <li><code>--logging=&lt;debug|info|error&gt;</code>: Sets the server's logging level (see below for more information).</li> <li><code>--backup</code>: Tries to restore the server state from a backup file. If the file is not found, the server will start with a clean state.</li> </ul> <p>Tip</p> <p>If you are running the server after a crash, maybe due to a power outage or connectivity problem, use the <code>--backup</code> flag to restore the previous state. If you want to learn more about how the server state is backed up, head over to the persistence page.</p> <p>Here's an example of using these parameters:</p> <pre><code>java -jar ./server-myshelfie.jar --server-address=192.168.1.51 --logging=debug\n</code></pre>"},{"location":"server/#logging","title":"Logging","text":"<p>Our server features robust logging capabilities, designed to provide comprehensive insights into server operations. Every log message is simultaneously displayed on the console and recorded in a log file named <code>server.log</code>. The log file is appended with new entries each time the server is run.</p> <p>The logging level can be defined by setting the <code>--logging</code> parameter at startup. Available values are:</p> <ul> <li><code>info</code>: Records all significant server events. This level corresponds to the <code>Loglevel.INFO</code> enum value.</li> <li><code>debug</code>: Captures all server events. This level corresponds to the <code>Loglevel.FINE</code> enum value.</li> <li> <p><code>error</code>: Logs only server errors. This level corresponds to the <code>Loglevel.SEVERE</code> enum value.</p> </li> <li> <p>By default, if not specified, the logging level is set to <code>info</code>.</p> </li> </ul> <p>Enjoy your journey as the game server operator and happy gaming!</p>"},{"location":"server/#using-docker","title":"Using Docker","text":"<p>You don't want to install Java on your server? No problem, we got you covered! We provide a Docker image that you can use to run the server and that bundles everything you need. To run it, simply execute the following command:</p> <pre><code>docker run -p 1099:1099 -p 1234:1234 myshelfiegc07/docker-myshelfie-server:latest\n</code></pre> <p>The Docker image also supports the same command-line arguments as the standalone server.</p> <p>Warning</p> <p>Due to the nature of the Docker networking system, you may encounter some issue with the RMI communication. If you encounter such issues, please run the Docker image using the host network: <code>docker run --network host myshelfiegc07/docker-myshelfie-server:latest</code></p>"},{"location":"test-coverage/","title":"Test coverage report","text":""},{"location":"test-coverage/#test-coverage-report","title":"Test coverage report","text":"<p>In adherence to the best practices of software engineering, we made sure that the core components of our code are well tested. By using a mix of unit tests and integration tests, we have achieved a class and method coverage of 100% and an overall line coverage of 92%.</p> <p>Here you can see the summary table of the coverage report:</p> Package Class coverage Method coverage Line <code>model</code> 100% 99% 97% <code>controller</code> 100% 97% 88% <p>And a more detailed report:</p> <p></p>"},{"location":"uml/","title":"UML diagrams","text":""},{"location":"uml/#uml-diagrams","title":"UML diagrams","text":"<p>During the development of this project, we have created several UML diagrams to help us understand the structure of the project and to help us communicate with each other.</p> <p>We described the architecture of the project using class diagrams:</p> <ul> <li>Client (overview)</li> <li>Client (detail)</li> <li>Server (overview)</li> <li>Server (detail)</li> <li>Complete architecture</li> <li>Model</li> <li>Network</li> </ul> <p>We also created sequence diagrams to describe the communication protocol between the client and the server:</p> <ul> <li>Client-server network communication protocol</li> </ul>"}]}